package com.mmsapre.platform.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.mmsapre.dsl.DslCommand;
import com.mmsapre.dsl.DslParserFacade;
import com.mmsapre.platform.registry.SchemaRegistryDao;
import com.mmsapre.platform.sql.*;
import com.mmsapre.platform.tenant.TenantContext;
import com.mmsapre.platform.util.JsonUtil;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.List;
import java.util.Map;

/**
 * Central execution engine.
 *
 * Orchestrates:
 *  - schema registry (maker–checker)
 *  - SCD-2 lifecycle
 *  - deduplication via hash_key
 *  - bulk COPY ingestion
 *  - search + aggregations
 *
 * IMPORTANT:
 *  - NO search_path
 *  - ALL SQL is schema-qualified
 */
@Service
public class DslExecutionService {

    private final DslParserFacade parser = new DslParserFacade();

    private final JdbcResolver jdbcResolver;
    private final SchemaRegistryDao registryDao;
    private final BulkService bulkService;
    private final HashService hashService;

    public DslExecutionService(
            JdbcResolver jdbcResolver,
            SchemaRegistryDao registryDao,
            BulkService bulkService,
            HashService hashService
    ) {
        this.jdbcResolver = jdbcResolver;
        this.registryDao = registryDao;
        this.bulkService = bulkService;
        this.hashService = hashService;
    }

    /* =========================================================
       ENTRY
     ========================================================= */

    public Object exec(TenantContext ctx, String dsl) {
        DslCommand cmd = parser.parse(dsl);
        return execute(ctx, cmd);
    }

    public Object execute(TenantContext ctx, DslCommand cmd) {

        JdbcTemplate jdbc = jdbcResolver.jdbc(ctx.alias());
        registryDao.ensure(jdbc);

        return switch (cmd.type()) {
            case CREATE  -> createDraft(jdbc, cmd.table(), cmd.json());
            case ALTER   -> alterDraft(jdbc, cmd.table(), cmd.json());
            case APPROVE -> approve(jdbc, ctx.schema(), cmd.table());

            case UPSERT  -> upsert(jdbc, ctx.schema(), cmd.table(), cmd.json());
            case BULK    -> bulk(jdbc, ctx.schema(), cmd.table(), cmd.json());

            case SEARCH  -> search(jdbc, ctx.schema(), cmd.table(), cmd.json());
            case DELETE  -> softDelete(jdbc, ctx.schema(), cmd.table(), cmd.json());
        };
    }

    /* =========================================================
       CREATE / ALTER / APPROVE (Maker–Checker)
     ========================================================= */

    private Object createDraft(JdbcTemplate jdbc, String table, String json) {
        JsonNode schema = JsonUtil.parse(json);
        int version = registryDao.nextVersion(jdbc, table);

        registryDao.saveDraft(jdbc, table, version, schema);

        return Map.of(
                "status", "DRAFT",
                "table", table,
                "version", version
        );
    }

    private Object alterDraft(JdbcTemplate jdbc, String table, String json) {
        return createDraft(jdbc, table, json);
    }

    private Object approve(JdbcTemplate jdbc, String schema, String table) {

        Map<String, Object> draft = registryDao.latestDraft(jdbc, table);
        if (draft == null) {
            throw new IllegalStateException(
                    "No DRAFT schema found for table: " + table
            );
        }

        int version = (int) draft.get("version");
        JsonNode schemaJson =
                JsonUtil.parse(draft.get("schema_json").toString());

        String physical =
                SqlNames.versioned(schema, table, version);

        List<String> ddls =
                DdlGenerator.createTableAndIndexes(
                        physical,
                        schemaJson
                );

        ddls.forEach(jdbc::execute);

        registryDao.activate(jdbc, table, version);

        return Map.of(
                "status", "ACTIVE",
                "table", table,
                "schema", schema,
                "physical_table", physical,
                "version", version
        );
    }

    /* =========================================================
       UPSERT (SCD-2 + DEDUP)
     ========================================================= */

    private Object upsert(
            JdbcTemplate jdbc,
            String schema,
            String table,
            String json
    ) {

        JsonNode payload = JsonUtil.parse(json);
        JsonNode record = payload.get("record");

        Map<String, Object> active =
                registryDao.active(jdbc, table);

        JsonNode schemaJson =
                JsonUtil.parse(active.get("schema_json").toString());

        int version = (int) active.get("version");
        String physical =
                SqlNames.versioned(schema, table, version);

        String hash =
                hashService.computeHash(
                        record,
                        schemaJson.path("hash_keys")
                );

        JsonNode scd = schemaJson.path("scd");
        boolean scd2 = scd.path("type").asInt(0) == 2;
        String activeFlag = scd.path("active_flag").asText("is_active");
        String endCol = scd.path("end_date").asText("valid_to");

        if (scd2) {
            SqlAndParams expire =
                    DmlGenerator.expireActive(
                            physical,
                            hash,
                            activeFlag,
                            endCol
                    );
            jdbc.update(expire.sql(), expire.params());
        }

        SqlAndParams insert =
                DmlGenerator.insert(physical, record, hash);

        jdbc.update(insert.sql(), insert.params());

        return Map.of(
                "result", "UPSERT_OK",
                "schema", schema,
                "table", table
        );
    }

    /* =========================================================
       BULK (COPY + DEDUP)
     ========================================================= */

    private Object bulk(
            JdbcTemplate jdbc,
            String schema,
            String table,
            String json
    ) {

        JsonNode payload = JsonUtil.parse(json);

        Map<String, Object> active =
                registryDao.active(jdbc, table);

        JsonNode schemaJson =
                JsonUtil.parse(active.get("schema_json").toString());

        int version = (int) active.get("version");
        String physical =
                SqlNames.versioned(schema, table, version);

        try {
            int count =
                    bulkService.bulkCopy(
                            jdbc,
                            physical,
                            schemaJson,
                            payload
                    );

            return Map.of(
                    "inserted", count,
                    "schema", schema,
                    "table", table
            );

        } catch (Exception e) {
            throw new RuntimeException("Bulk COPY failed", e);
        }
    }

    /* =========================================================
       SEARCH + AGGREGATIONS
     ========================================================= */

    private Object search(
            JdbcTemplate jdbc,
            String schema,
            String table,
            String json
    ) {

        JsonNode payload = JsonUtil.parse(json);

        Map<String, Object> active =
                registryDao.active(jdbc, table);

        JsonNode schemaJson =
                JsonUtil.parse(active.get("schema_json").toString());

        int version = (int) active.get("version");
        String physical =
                SqlNames.versioned(schema, table, version);

        JsonNode where = payload.path("query");
        JsonNode aggs = payload.get("aggs");

        boolean scd2 =
                schemaJson.path("scd").path("type").asInt(0) == 2;

        String activeFlag =
                schemaJson.path("scd")
                        .path("active_flag")
                        .asText("is_active");

        if (aggs != null && aggs.isObject()) {
            String sql =
                    AggregationSqlBuilder.build(
                            physical,
                            aggs,
                            scd2,
                            activeFlag
                    );
            return jdbc.queryForList(sql);
        }

        NamedParameterJdbcTemplate np =
                new NamedParameterJdbcTemplate(jdbc);

        String sql =
                DmlGenerator.selectHitsSql(
                        physical,
                        where,
                        scd2,
                        activeFlag,
                        "valid_from",
                        "valid_to",
                        payload.path("as_of").asText(null),
                        payload.path("size").asInt(10),
                        payload.path("from").asInt(0)
                );

        return np.queryForList(
                sql,
                JsonUtil.om().convertValue(where, Map.class)
        );
    }

    /* =========================================================
       SOFT DELETE
     ========================================================= */

    private Object softDelete(
            JdbcTemplate jdbc,
            String schema,
            String table,
            String json
    ) {

        JsonNode payload = JsonUtil.parse(json);
        JsonNode businessKey = payload.get("business_key");

        Map<String, Object> active =
                registryDao.active(jdbc, table);

        JsonNode schemaJson =
                JsonUtil.parse(active.get("schema_json").toString());

        int version = (int) active.get("version");
        String physical =
                SqlNames.versioned(schema, table, version);

        boolean scd2 =
                schemaJson.path("scd").path("type").asInt(0) == 2;

        String activeFlag =
                schemaJson.path("scd")
                        .path("active_flag")
                        .asText("is_active");

        String endCol =
                schemaJson.path("scd")
                        .path("end_date")
                        .asText("valid_to");

        String hash =
                hashService.computeHash(
                        businessKey,
                        schemaJson.path("hash_keys")
                );

        SqlAndParams sql =
                DmlGenerator.softDelete(
                        physical,
                        hash,
                        scd2,
                        activeFlag,
                        endCol
                );

        jdbc.update(sql.sql(), sql.params());

        return Map.of(
                "deleted", true,
                "timestamp", Instant.now()
        );
    }
}
