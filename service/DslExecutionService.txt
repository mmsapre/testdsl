package com.mmsapre.platform.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.mmsapre.dsl.DslCommand;
import com.mmsapre.dsl.DslParserFacade;
import com.mmsapre.platform.registry.SchemaRegistryDao;
import com.mmsapre.platform.sql.*;
import com.mmsapre.platform.util.JsonUtil;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.List;
import java.util.Map;

/**
 * Central execution engine.
 *
 * Orchestrates:
 *  - schema registry (maker–checker)
 *  - SCD-2 lifecycle
 *  - deduplication via hash_key
 *  - bulk COPY ingestion
 *  - search + aggregations
 */
@Service
public class DslExecutionService {

    private final DslParserFacade parser = new DslParserFacade();

    private final JdbcResolver jdbcResolver;
    private final SchemaRegistryDao registryDao;
    private final BulkService bulkService;
    private final HashService hashService;

    public DslExecutionService(
            JdbcResolver jdbcResolver,
            SchemaRegistryDao registryDao,
            BulkService bulkService,
            HashService hashService
    ) {
        this.jdbcResolver = jdbcResolver;
        this.registryDao = registryDao;
        this.bulkService = bulkService;
        this.hashService = hashService;
    }

    /* =========================================================
       ENTRY
     ========================================================= */

    public Object exec(String dsl) {
        DslCommand cmd = parser.parse(dsl);
        return execute(cmd);
    }

    public Object execute(DslCommand cmd) {

        JdbcTemplate jdbc = jdbcResolver.jdbc(cmd.alias());
        registryDao.ensure(jdbc);

        return switch (cmd.type()) {
            case CREATE  -> createDraft(jdbc, cmd.table(), cmd.json());
            case ALTER   -> alterDraft(jdbc, cmd.table(), cmd.json());
            case APPROVE -> approve(jdbc, cmd.table());

            case UPSERT  -> upsert(jdbc, cmd.table(), cmd.json());
            case BULK    -> bulk(jdbc, cmd.table(), cmd.json());

            case SEARCH  -> search(jdbc, cmd.table(), cmd.json());
            case DELETE  -> softDelete(jdbc, cmd.table(), cmd.json());
        };
    }

    /* =========================================================
       CREATE / ALTER / APPROVE (Maker–Checker)
     ========================================================= */

    private Object createDraft(JdbcTemplate jdbc, String table, String json) {
        JsonNode schema = JsonUtil.parse(json);
        int version = registryDao.nextVersion(jdbc, table);

        registryDao.saveDraft(jdbc, table, version, schema);

        return Map.of(
                "status", "DRAFT",
                "table", table,
                "version", version
        );
    }

    private Object alterDraft(JdbcTemplate jdbc, String table, String json) {
        JsonNode schema = JsonUtil.parse(json);
        int version = registryDao.nextVersion(jdbc, table);

        registryDao.saveDraft(jdbc, table, version, schema);

        return Map.of(
                "status", "DRAFT",
                "table", table,
                "version", version
        );
    }

    private Object approve(JdbcTemplate jdbc, String table) {

        Map<String, Object> draft = registryDao.latestDraft(jdbc, table);
        if (draft == null) {
            throw new IllegalStateException("No DRAFT schema found for table: " + table);
        }

        int version = (int) draft.get("version");
        JsonNode schema = JsonUtil.parse(draft.get("schema_json").toString());

        String physical = DdlGenerator.physicalTable(table, version);

        List<String> ddls = DdlGenerator.createTableAndIndexes(physical, schema);
        ddls.forEach(jdbc::execute);

        registryDao.activate(jdbc, table, version);

        return Map.of(
                "status", "ACTIVE",
                "table", table,
                "physical_table", physical,
                "version", version
        );
    }

    /* =========================================================
       UPSERT (SCD-2 + DEDUP)
     ========================================================= */

    private Object upsert(JdbcTemplate jdbc, String table, String json) {

        JsonNode payload = JsonUtil.parse(json);
        Map<String, Object> active = registryDao.active(jdbc, table);
        JsonNode schema = JsonUtil.parse(active.get("schema_json").toString());

        int version = (int) active.get("version");
        String physical = DdlGenerator.physicalTable(table, version);

        JsonNode businessKey = payload.get("business_key");
        JsonNode record = payload.get("record");

        JsonNode scd = schema.path("scd");
        boolean scd2 = scd.path("type").asInt(0) == 2;
        String activeFlag = scd.path("active_flag").asText("is_active");
        String endCol = scd.path("end_date").asText("valid_to");

        if (scd2) {
            SqlAndParams expire =
                    DmlGenerator.expireActive(
                            physical, businessKey, activeFlag, endCol);
            jdbc.update(expire.sql(), expire.params());
        }

        String hash = hashService.computeHash(record, schema.path("hash_keys"));
        SqlAndParams insert = DmlGenerator.insert(physical, record, hash);

        jdbc.update(insert.sql(), insert.params());

        return Map.of("result", "UPSERT_OK");
    }

    /* =========================================================
       BULK (COPY + SCD-2 + DEDUP)
     ========================================================= */

    private Object bulk(JdbcTemplate jdbc, String table, String json) {

        JsonNode payload = JsonUtil.parse(json);
        Map<String, Object> active = registryDao.active(jdbc, table);
        JsonNode schema = JsonUtil.parse(active.get("schema_json").toString());

        int version = (int) active.get("version");
        String physical = DdlGenerator.physicalTable(table, version);

        try {
            int count = bulkService.bulkCopy(jdbc, physical, schema, payload);
            return Map.of("inserted", count);
        } catch (Exception e) {
            throw new RuntimeException("Bulk COPY failed", e);
        }
    }

    /* =========================================================
       SEARCH + AGGREGATIONS
     ========================================================= */

    private Object search(JdbcTemplate jdbc, String table, String json) {

        JsonNode payload = JsonUtil.parse(json);
        Map<String, Object> active = registryDao.active(jdbc, table);
        JsonNode schema = JsonUtil.parse(active.get("schema_json").toString());

        int version = (int) active.get("version");
        String physical = DdlGenerator.physicalTable(table, version);

        JsonNode where = payload.path("query");
        JsonNode aggs = payload.get("aggs");

        boolean scd2 = schema.path("scd").path("type").asInt(0) == 2;
        String activeFlag = schema.path("scd")
                .path("active_flag").asText("is_active");

        if (aggs != null && aggs.isObject()) {
            String sql =
                    AggregationSqlBuilder.build(
                            physical, aggs, scd2, activeFlag);
            return jdbc.queryForList(sql);
        }

        NamedParameterJdbcTemplate np = new NamedParameterJdbcTemplate(jdbc);

        String sql =
                DmlGenerator.selectHitsSql(
                        physical,
                        where,
                        scd2,
                        activeFlag,
                        "valid_from",
                        "valid_to",
                        payload.path("as_of").asText(null),
                        payload.path("size").asInt(10),
                        payload.path("from").asInt(0)
                );

        return np.queryForList(
                sql,
                JsonUtil.om().convertValue(where, Map.class)
        );
    }

    /* =========================================================
       SOFT DELETE (GENERIC)
     ========================================================= */

    private Object softDelete(JdbcTemplate jdbc, String table, String json) {

        JsonNode payload = JsonUtil.parse(json);
        JsonNode businessKey = payload.get("business_key");

        Map<String, Object> active = registryDao.active(jdbc, table);
        JsonNode schema = JsonUtil.parse(active.get("schema_json").toString());

        int version = (int) active.get("version");
        String physical = DdlGenerator.physicalTable(table, version);

        boolean scd2 = schema.path("scd").path("type").asInt(0) == 2;
        String activeFlag = schema.path("scd")
                .path("active_flag").asText("is_active");
        String endCol = schema.path("scd")
                .path("end_date").asText("valid_to");

        SqlAndParams sql =
                DmlGenerator.softDelete(
                        physical, businessKey, scd2, activeFlag, endCol);

        jdbc.update(sql.sql(), sql.params());

        return Map.of(
                "deleted", true,
                "timestamp", Instant.now()
        );
    }
}
